## 소개
2018년 세종대학교에서 열린 JetBrains Day에서 Kotlin/JVM 세션만 들으며 내가 보고 들은 것을 메모한 문서입니다.

## REMOVING BARRIERS

* 정말 내가 평소에 존경하던 분의 발표를 들으니 정말 기뻤다. 이 발표에서는 개발자의 장벽을 없애는 법을 알려주셨다.
* 자유롭게 일하고 자유롭게 소통하는 젯브레인 사의 기업 문화를 소개하면서도 이 것을 내가 앞으로 공부할 때나 취업을 나가서도 어떻게 활용할 것인가를 자세하고 임펙트있게 발표해주셨다.
* 그리고 '리더란 무엇일까?' 또, 소통을 하려면 다른 사람의 문화를 이해해야하고 앞으로 나아가면서 자신만의 문화를 잃지 말라는 조언까지 해주신 유익할 발표였다.

* **정리**: 개발자들의 장벽을 지우고 서로 소통하자, 자신만의 문화를 이어가자라고 정말 좋은 말씀들을 해주셨다. 그리고 추가적으로 JetBrain의 좋은 기업문화도 알게 되었다.
* **느낀점**: 영어 발표을 듣는 것도 처음이고 이렇게 대단한 분의 발표를 듣는 것도 처음이었다. 나는 분명 한국에서 발표를 듣고 있는데 마치 미국의 엄청 큰 곳에서 발표를 듣는 듯한 발표였다.

## 소프트웨어를 모르는 대한민국의 위기

* 비개발자와 개발자에 대한 발표였다. 개발자의 문화? 지식을 비개발자는 아직 이해하지 못한다는 것이다. 
* 하지만 최근 GitHub의 인수 등의 사례를 예시로 들며, 현재 개발자들의 문화의 가치가 상승하고 있다는 사실을 이야기해 주셨다. 
* 앞으로는 개발자의 세상은 계속될 것이며 그 세상 안에서 나만의 사회적 가치를 만들라고 하신 발표였다.

* **정리**: 개발자 자신의 사회적 가치를 높이고, 개발자들의 문화가 점점 인정 받기 시작했다는 이야기였다.
* **느낀점**: 개발을 공부한지 얼마되지 않았지만 개발자들의 문화를 알게 된 후 비개발자들의 문화를 잊어버린 나를 되돌아볼 수 있는 시간이었다.

## IntelliJ Tips & Tricks

* JetBrains의 ToolBox는 무료이다. 또, 세팅도 공유할 수 있다. 

* 더블 쉬프트는 윈도우를 열어 모든 파일을 찾는 기능을 가지고 있는 반면, 이번 2018.3 에서 추가된 더블 컨트롤은 모든 것을 구도잇킬 수 있는 기능을 가지고 있다.

* 스토어에서 플러그인을 지원하는데 Nyan ??(뭐였지)이 있는데 매우 귀엽다고 한다.

* 자주 사용하는 구조가 저장된 장소가 있으며 자동완성 기능이 지원이 된다. 

* String에 JSON 형식으로 저장하는 경우가 있는데 이를 하나하나 다 쓰기에는 너무 귀찮다. 그래서 인텔리제이는 json을 치면 어떤 기능이 제공이 되는데 이 기능은 그냥 문장을 치면 JSON으로 변환 시켜준다.

* 플러그인에 AceJump를 검색한 후 사용할 경우 드래그가 편리해진다.
* 쉬프트 컨트롤 3을 누르면 변수의 타입을 볼 수 있는데 좀더 자세하게 보면 이전에 썼던 코드를 인텔리제이가 읽어 나올 수 있는 자료형이나 데이터 범위를 알려준다.

* Structure Search라는 기능도 제공하는데 만약 예외 처리가 있다면 나 코드 중 그 특정한 코드 패턴이 어디에 있는지 찾을 수 있다. 또 그 패턴을 사용하면 안되는 경우 자신이 따로 에러로 표시하는 등의 설정을 할 수 있다.

* git을 사용하는 것도 고려하였는데 바뀐 파일을 체크, 체크 아웃하는 동작, 늦게 커밋하기 등의 설정을 통해 커밋을 인텔리제이 안에서 조절할 수 있다.

* 인텔리제이 안에 포스트맨이 있다. 놀랍다. test 파일을 열어 통신을 테스팅할 수 있다. 그래서 자바로 서버를 개발할 때 따로 UI 작업을 할 필요가 없어집니다.

* JetBrains의 IntelliJ github에 가면 IntelliJ의 여러가지 기능, Spring, Scala 등의 새로운 기능을 살펴볼 수 있다.

* **정리**: 솔직히 다 알아듣지도 정확히 알아 듣지도 못했다. 그래도 정리하자면 IntelliJ의 플러그인 을 이용하면 정말 편리하고 진짜 편리한 기능들이 많다는 것을 알 수 있다. 
* **느낀점**: 영어 발표을 듣는 것도 처음이고 이렇게 대단한 분의 발표를 듣는 것도 처음이었다. 나는 분명 한국에서 발표를 듣고 있는데 마치 미국의 엄청 큰 곳에서 발표를 듣는 듯한 발표였다.

## Kotlin - What's New

* 코루틴은 lauch를 하게 되면 실행되는 아주 가벼운 스레드이다. 어느한 코루틴이 오류가 나면 다른 코루틴에 문제가 생길 수 있다. CoroutineScope를 상속하면 그 클래스 안에서 여러 Coroutine의 코드를 사용할 수 있다. 

* 코틀린에서 스테이트를 사용할 때의 활용할 수 있는 점이다. 만약 when 문을 스테이트로 사용할 때 val x = when(haha){ 10 -> 30 else -> 40} 으로 사용하는 것이 좋다.

* 그리고 코틀린은 자바를 기본으로 하지만 static 같이 코틀린에는 없는 기능이 있다. 하지만 @JVMStatic 등을 이용하여 이것을 극복할 수 있다.

* 어노테이션 클래스를 정의할 수 있다. anotation class 이다. 이를 정의하고 라우팅 어노테이션을 통해 정의한 .정의한 함수 로 사용할 수 있다.

* inline 함수를 쓰는 이유: 인라인은 그렇게 중요하지 않지만 인라인이 유용할 때가 있는데 고차함수에서 유용하다. 
    * 만약 두개의 함수를 쓸 때 인자로 하나의 함수의 인자로 람다로 받는다고 하면 inline을 쓰는 것이 좋다.
    * 그래서 inline을 퍼포먼스를 위해 쓰는 경우도 있고 reified 를 위해서 쓰는 경우가 있다. 
    * 또 신기한 게 있는데 파라미터 안에서 noinline을 통해 inline하지 않을 수도 있으면 crossinline이라는 것도 있다.
    * Inline 클래스도 추가되었다. 

* typealias도 추가되었다. typealias는 코드를 잘 이해하기 위해서도 사용하지만 다른 부분에서 사용하기도 한다. 
    * 예를 들어 기존의 클래스를 다른 클래스로 바꿔야하는 경우가 있다면 typealias에 기존 클래스를 담은 채로 사용하게 되면 기존 클래스는 유지한채 클래스를 교체할 수 있다.

* 코틀린의 람다는 자바에서의 람다보다 한단계 더 나아갔다.(이부분을 까먹었다.)

* @JVMDefault: 코틀린은 interface를 위한 Default를 사용할 수 없다. 하지만 만약 자바와 코틀린을 같이 사용해야하는 경우 Default가 필요한데 이 경우 이 것을 이용한다.

* **정리**: Kotlin 1.3 버전의 추가 내용이다.
* **느낀점**: 진짜 내가 아는 Kotlin은 Kotlin이 아니었구나라는 생각이 들었다.

## Kotlin/Anywhere

* 사실은 Kotlin은 모바일을 목적으로 나온 언어가 아닌 모든 어플리케이션 개발을 할 때 사용할 수 있도록 하는 산업용 언어의 목적을 가지고 있다. 
* Kotlin/JVM, Kotlin/Javascript, Kotlin/Native로 나뉜다. Kotlin/JVM(.kt)은 우리가 흔히 아는 안드로이드 개발을 하거나 Spring Boot로 서버를 개발할 때 사용하는 것이고
* Kotlin/Javascript(.kts)는 웹 프론트(리액트 사용가능!!), Hosting 용도로도 사용이 가능하다. 제일 이 발표의 대부분을 차지했던 것은 바로 Kotlin/Native 이다. 
* Kotlin/Native는 IOS, 안드로이드, 리눅스, 맥OS 개발 등을 할 때 사용하는데 아직 베타버전이고 내년 즈음이면 완성될 것 같다고 한다. 
    * Kotlin의 아버지가 말하시길 Kotlin/Native가 완성되면 Linux 급의 파급력을 기대할 수 있다고 한다.

* **정리**: Kotlin은 앞으로 어디서든이 쓰일 것이라는 이야기였다.
* **느낀점**: 앞으로 Kotlin의 미래가 더욱 기대되는 발표였다.

## Kotlin에서 재공하는 Coroutines을 사용하는 방법

* 우리가 알고있는 함수는 호출한 곳으로 돌아오기 위해서는 return이 있어야 한다.
* 코루틴은 Entry point 여러 개 허용하는 subroutine이고 언제든 일시 정지, 실행 가능하다.
* 코루틴은 스레드이지만 거의 비용이 발생하지 않으며, 라이트 웨이트 스레드라고 한다. - cpu에 부담 x
* CoroutineScope 모든 코루틴을 동작시키는데 최상위 인터페이스이다. 
    * 코루틴 정의를 위한 Scope 제공, CoroutineContext 형태를 지정, launch, async 등을 통해 실행 정의 가능 
    * lifecycle은 Android에서 Activity Lifecycle을 따른다. 
    * (예: Destory 시 cancel을 통해 모든 코루틴 종료) 
    * Job은 launch를 했을 때 반환되는 모든 코루틴 동작의 중심, 비동기 처리를 할 때 .join 이용

##### 기능 및 함수
* GlobalScope - CoroutineScope의 객체로 보면 됨 Demon Lifecycle을 따름
* launch - 코루틴 실행 시켜주는 친구
* async/await : async는 코드 블락, await는 코드 블락이 종료하기를 기다림
* Actor: actor에 메시지를 전송하고 이를 처리할 수 있다. actor<T> -> {} 형태로 처리가
* Channel: 넣어서 출력하는 형태 - 데이터를 send할 수 있다.
* produce: 채널과 반대로 받아서 출력하는 형태 - 데이터를 send할 수 있다.
* Dispatcher: 코루틴의 스레드 분리를 도와주는 친구
* suspend: suspent 키워드를 추가하여 함수 분할, 정의한 함수를 사용하기 전까지 동작하지 않음, CoroutineScope내에서만 사용 가능

* rxJava와 함께 사용이 가능하며 Kotlin github에 가면 rxjava와 coroutine을 함께 사용한 예제와 디렉토리가 있다.

* **정리**: Kotlin coroutine에 대해 자세히 알아보었다.
* **느낀점**: coroutine을 혼자 공부할 때는 이해하기 어려웠는데 이렇게 들으니까 쉽게 이해할 수 있었다.

## Kotlin @ coupang Backend 적용기

* Kotlin의 Coroutine과 Extension method 등을 이용하여 서버의 퍼포먼스 개선. 빠르다고 한다.

* **정리**: 코틀린으로 서버를 짜도 좋다는 것을 알게되었다.
* **느낀점**: 발표를 제대로 못들어서 아쉽다.
