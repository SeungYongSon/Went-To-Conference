## 소개

2018년 대전에서 열린 GDG Devfest Daejeon의 발표를 들으면서 제가 이해한만큼 메모한 걸 정리한 문서입니다.

## Android 에서 Koin으로 DI하기
* Koin은 객체지향 5대원칙중 디펜던시에 대한 문제임
    * 많은 인스턴스로 인한 부담
    * DI 도입이 필요성이 높아짐
    * Dagger, V2 버전임
    * 인지도가 높으며 안전한 DI 라이브러리
    * 가볍게 시작할 수 있음

* Koin 문법
    * module: koin Module 정의
    * factory: 인스턴스 생성
    * single: 싱클톤 인스턴스
    * (Sub) module: 하위 모듈임
    * ~ 더 있음 근데 못적음 ~

* 신기한건 Koin은 Log를 자동으로 찍어줘서 디버깅하기 쉽다.

* 안드로이드 패턴 중에 MVP 패턴 방법 중 Presenter/PresenterImpl에 모듈을 적용시켜서 쉽게 인터페이스를 바인딩할 수 있다.

* 사용 예
    * single{ArrayList<String>} - 위와 같이는 사용불가
    * sigle{name: dfsfsd}(ArrayList<String>) - 네이밍을 해주어야 사용가능

* 모듈화할 것을 찾고 리팩토링을 한 후 Koin과 인젝션을 시작하면 된다. ( 사용 순서 )

* 또 다른 Koin 함수
    * by inject() - 지연 취득
    * get - 인스턴스 얻음
    * release - ???
    * getProperty ?????

* 안드로이드에서 Activity onCreate안에 startKoin(만든 모듈)을 해주면 그 클래스 내에서 자신이 구현한 모든 모듈을 바로 사용할 수 있다.

* Koin은 ViewModel도 지원한다. getViewModel, by ViewModel, by shareViewModel, getshareViewModel 등의 함수들을 지원한다.
* MVVM 아키텍쳐 패턴을 간결하게 사용할 수 있도록 한다.

* 사용법은 sigle이나 modul과 마찬가지로 {}블럭에 ViewModel을 넣어주면 된다. 그래서 이랍ㄴ Koin과 사용법은 큰차이가 없다. 

* 장점: 쉽고 직관적이다, Logger 존재 - 디버깅 쉬움, 빠른 빌드, 프로식 코드 생성, 리플렉션 미사용
* 단점: Service Locator Pattern, Overhead(오버헤드가 큼), Runtime Error(Koin 작성에 문제가 있을 경우 컴파일이 아닌 런타임에서 에러가 남), 아직 1.1.0버전 밖에 나오지 않아 Constructor Injection을 지원하지 않는다.

* 참고: Service Locator Pattern은 인스턴스에 의존성을 주입하는 패턴 중 하나임

* **정리**: 프로젝트를 진행할 때 인스턴스가 너무 많아지는 문제가 발생하는 데 이를 해결하기 위해 Dagger라는 라이브러리도 있지만 Koin이라는 라이브러리가 생겼다. Koin은 여러 아키텍쳐 패턴과 잘 어울리며 SL 패턴이 아닌 DI 패턴을 사용한다. 입문이 쉽고 빌드 속도는 빠르며, 아직 나온지 얼마 안되 오버헤드나 런타임 에러가 발생한다는 오점은 존재한다.
* **느낀점**: 뭐 눈에는 뭐만 보인다고 아직 아는 것이 없어서 이 좋은 발표를 잘 흡수하지 못했던 것 같다. 발표자님의 말씀으로는 도큐먼트에 Koin이 잘 설명되어 있다고 하니 한번 보는 것도 좋을 듯하다. 아니다. 그냥 오늘 보자!

## Kubernetes로 보는 CaaS

* SaaS - Google drive, dropbox - 코딩같은 거 필요없이 그냥 가져다 쓰면 됨
* PaaS - platform 기반 - 데이터 레벨만 건드리면 됨
* IaaS - AWS, openstack  - 소프트웨어만 건드리면 됨
* CaaS - 도커는 컨테이너를 배포하는 형식으로 나누어줌 

* 도커를 쓰는 이유는 아파치에 비해 설치도 쉽고 간단하게 사용할 수 있어서 사용한다.
* 도커 허브에는 각 컨테이너가 있으며 클라이언트 쪽에서는 도커 호스트에 있는 Image로 구별한다. 
* 그래서 클라이언트의 build는 이미지에, run은 이미지를 가져와서 컨테이너를 실행한다. pull은 허브에서 호스트로, push는 이미지에서 호스트로 동작한다.

* 도커는 우분투 같은 OS 위에 설치되어서 도커가 각 컨테이너를 관리할 수 있게 한다.
* 컨테이너는 물리적인 컴퓨터가 꺼지게 되면 사라지는 휘발성을 지니고 있기 때문에 중요한 데이터를 저장하려면  host에 래핑하여 저장하는 것이 좋다.

* 도커는 파일 설정하고 compose 함. - 여기는 무슨 소리인지 모르것다.. 

* Kubernetes는 단일 서버가 아니라 클러스터 단위라서 물리적으로 네트워크를 공유하고 있지 않다 그래서 IP를 따로 Master Node에 설정해줄 수 있다.
* 토큰은 24시간 후에 사라져서 Master Node에 가서 사라지면 다시 재발급을 받고 Slave Node에 적용 시켜주면 된다.
* 최고 관리자만 대시보드를 사용할 수 있다.

* Kubernetes를 안정적으로 사용하기 위해서는 Kubernetes가 종료되었을 때 데이터를 저장하는 등의 System 디자인을 잘해놓아야 한다.

* Kubernetes는 클러스터로 되어 있어서 도커보다 관리가 쉽다는 장점이 존재.

* **정리**: 클라우드 서비스는 4가지 서비스가 있다. SaaS, PaaS, IaaS, CaaS. 그 중 Kubernetes는 Caas에 속하고 도커보다 관리하기 쉽다는 장점으로 가지고 있으며 클러스터 단위로 작동한다. 실업에서는 네트워크 속도를 측정하는데에 쓰기도 한다고 한다.
* **느낀점**: 내가 클라우드 공부를 하나도 안했는데 그런 나도 어려운 내용을 조금은 알아들을 정도로 쉽게 설명해주셔서 좋았던 발표이다.

## Flutter 101

* 저번주에 갔던 GDG Devfest Seoul의 발표자분과 발표주제, 발표내용이 같다. 그래서 적을 건 없었다... 
* **정리, 느낀점**: 와! Flutter!

## Progressive Web Apps:Next step for web developers

* PWA는 일렉트론 같이 자바스크립트를 감싸는 것이 아니라 이미지의 집합이다.
* 하나의 속임수라고 볼 수 있다. 사실은 Web이지만 사용자는 다운로드해서 App처럼 쓸 수 있다. 그래서 브라우저가 아닌 홈에서 아이콘을 선택해 들어간다.
* 또, 사용자가 App으로 속을 수 있게 뒤로가기 버튼은 없으며, 주소창도 없다.
* 앱처럼 오프라인에서도 들어갈 수 있게 Service Worker라는 클라이언트와 서버의 중간에 매개체를 놓는다. 이 Service Worker는 PWA를 다운받을 때 같이 다운된다.

* **정리**: PWA는 웹을 앱처럼 만들고 싶던 개발자들의 꿈이다. 하지만 이건 웹이다.
* **느낀점**: 발표자분이 굉장히 발표를 잘하시는 분이었다. 40여분이라는 긴 시간동안 집중하지 않을 수 없게 발표하셨다. 그리고 개인적인 생각인데 이런 App을 대체하는 기술들을 들을 때마다 Android를 공부하는 나는 조금 불안하다...

## 네트워킹 시간
* **아쉬운 점**: 네트워킹도 해보고 싶었지만 기숙사 외출시간 때문에 네트워킹 시간에는 참여하지 못했다...